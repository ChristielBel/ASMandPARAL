#include <iostream>
#include <time.h>
#include <omp.h>
#include <random>
#include <chrono>
#include <vector>
using namespace std;

bool calculate_inverse_matrix(vector <vector<double>>& matrix)
{
    int matrix_size = matrix.size();
    vector <vector<double>> T(matrix_size, vector<double>(matrix_size));

    for (int i = 0; i < matrix_size; i++)
    {
        for (int j = 0; j < matrix_size; j++)
        {
            if (i == j) T[i][j] = 1.0;
            else T[i][j] = 0.0;
        }
    }

    for (int k = 0; k < matrix_size; k++)
    {
        if (abs(matrix[k][k]) < 1e-8)
        {
            bool flag = false;

            for (int i = k + 1; i < matrix_size; i++)
            {
                if (abs(matrix[i][k]) > 1e-8)
                {
                    swap(matrix[k], matrix[i]);
                    swap(T[k], T[i]);
                    flag = true;
                    break;
                }
            }

            if (!flag)
                return false;
        }

        double temp = matrix[k][k];

#pragma omp parallel
        {
#pragma omp for
            for (int j = 0; j < matrix_size; j++)
            {
                matrix[k][j] /= temp;
                T[k][j] /= temp;
            }
        }

#pragma omp parallel
        {
#pragma omp for
            for (int i = k + 1; i < matrix_size; i++)
            {
                double temp = matrix[i][k];


                for (int j = 0; j < matrix_size; j++)
                {
                    matrix[i][j] -= temp * matrix[k][j];
                    T[i][j] -= temp * T[k][j];
                }
            }
        }
    }

    for (int k = matrix_size - 1; k > 0; k--)
    {
#pragma omp parallel
        {
#pragma omp for
            for (int i = k - 1; i > -1; i--)
            {
                double temp = matrix[i][k];

                for (int j = 0; j < matrix_size; j++)
                {
                    matrix[i][j] -= temp * matrix[k][j];
                    T[i][j] -= temp *T[k][j];
                }
            }
        }
    }
    matrix = T;
    return true;
}

double generate_random_number(const int min, const int max)
{
    random_device rd;
    mt19937 gen(rd());
    uniform_real_distribution<double> dis(min, max);
    return dis(gen);
}

int main()
{
    srand(time(NULL));
    setlocale(LC_ALL, "RUS");
    int n;
    cout << "Введите количество уравнений: ";
    cin >> n;

    vector<vector<double>> matrix(n, vector<double>(n));
    vector<double> B(n);

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
            matrix[i][j] = generate_random_number(0, 100);
        B[i] = generate_random_number(0, 100);
    }

    auto start_time = chrono::high_resolution_clock::now();

    if (!calculate_inverse_matrix(matrix))
    {
        cout << "Error!\n";
        exit(1);
    }

    vector<double> X(n);
#pragma omp parallel
    {
#pragma omp for
        for (int i = 0; i < n; i++)
        {
            X[i] = 0;
            for (int j = 0; j < n; j++)
                X[i] += matrix[i][j] * B[j];
        }
    }

    auto end_time = chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time);

    cout << "Time: " << duration.count() << " microseconds";

    return 0;
}
